---
title: "Query openrouteservice from R"
author: "Andrzej OleÅ›"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_document:
    toc: true
    toc_float: true
vignette: >
  %\VignetteIndexEntry{Query openrouteservice from R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r config, include=FALSE}
## set up knitr defaults
knitr::opts_chunk$set(eval=TRUE, out.width='100%', out.height='560px')
```

## Get started

<!-- README START -->
```{r doc, include=FALSE}
## create alias
doc <- openrouteservice:::doc_link
```

*openrouteservice* R package provides easy access to the
[openrouteservice](https://openrouteservice.org) (ORS) API from R. It allows you
to painlessly consume the following services:

  - `r doc('directions')` (routing)
  - `r doc('geocode')` powered by [Pelias](https://pelias.io)
  - `r doc('isochrones')` (accessibility)
  - time-distance `r doc('matrix')`
  - `r doc('pois')` (points of interest)
  - `r doc('elevation')` (SRTM elevation for point and lines geometries)

### Disclaimer

By using this package, you agree to the ORS [terms and
conditions](https://openrouteservice.org/terms-of-service/).

### Installation

The package is not yet available from CRAN, but you can install the
development version directly from GitHub.

```{r installation, eval=FALSE}
# install.packages("remotes")
remotes::install_github("GIScience/openrouteservice-r")
```
<!-- README END -->

### Setting up API key

In order to start using ORS services you first need to set up your personal API
key, which you can `r openrouteservice:::signup_url("get for free")`.

```{r api_key, eval=FALSE}
library(openrouteservice)

ors_api_key("<your-api-key>")
```

This will save the key in the default keyring of your system credential store.
Once the key is defined, it persists in the keyring store of the operating
system. This means that it survives beyond the termination of the R session, so
you don't need to set it again each time you start a new R session. To retrieve
the key just call `ors_api_key()` without the `key` argument.

Alternatively, they key can be provided in the environment variable
`ORS_API_KEY`. The value from the environment variable takes precedence over the
former approach allowing to bypass the keyring infrastructure.


## Directions

`ors_directions()` interfaces the ORS directions service to compute routes
between points provided in `coordinates`.

```{r directions, eval=TRUE}
library(openrouteservice)

coordinates <- list(c(8.34234, 48.23424), c(8.34423, 48.26424))

x <- ors_directions(coordinates)
```

Way points can be provided as a list of coordinate pairs `c(lng, lat)`, or a
2-column matrix-like object such as a data frame.

```{r data_frame}
coordinates <- data.frame(lng = c(8.34234, 8.34423), lat = c(48.23424, 48.26424))
```

By default the response is formatted as geoJSON which allows to easily
[visualize](https://rstudio.github.io/leaflet/json.html#working-with-raw-geojsontopojson)
it with e.g. [leaflet](https://CRAN.R-project.org/package=leaflet).

```{r leaflet}
library(leaflet)

leaflet() %>%
  addTiles() %>%
  addGeoJSON(x, fill=FALSE) %>%
  fitBBox(x$bbox)
```

Other output formats, such as GPX, can be specified in the argument `format`.
Note that in plain JSON response the geometry is returned as [Google's encoded
polyline](https://developers.google.com/maps/documentation/utilities/polylinealgorithm).

```{r googlepolyline}
x <- ors_directions(coordinates, format = "json")

geometry <- x$routes[[1]]$geometry
str(geometry)

library(googlePolylines)
str(decode(geometry))
```

The API offers a wide range of `profile`s for multiple modes of transport: car,
and heavy vehicle, different bicycle types, walking, hiking and wheelchair.
These can be listed with

```{r profiles}
ors_profile()
```

Each of these modes uses a carefully compiled street network to suite the
profiles requirements.

```{r bicycle}
x <- ors_directions(coordinates, profile="cycling-mountain")

leaflet() %>%
  addTiles() %>%
  addGeoJSON(x, fill=FALSE) %>%
  fitBBox(x$bbox)
```

Any optional `r openrouteservice:::doc_link('directions', 'query parameters')`
can be specified by providing them as additional `...` arguments to
`ors_directions`. For example, in order to plot the elevation profile of a route
colored by steepness use `elevation = TRUE` to add height to the coordinates of
the points along the route and query for steepness in `extra_info`.

```{r cycling_mountain, message=FALSE}
x <- ors_directions(coordinates, profile = "cycling-mountain", elevation = TRUE,
                    extra_info = I("steepness"), output = "sf")

library("sf")
height <- st_geometry(x)[[1]][, 3]
```

Length of individual route segments and their distance relative to the starting
point can be computed with `st_distance()` upon converting the `LINESTRING` to a
list of `POINT`s,

```{r segments}
points <- st_cast(st_geometry(x), "POINT")

n <- length(points)

segments <- cumsum(st_distance(points[-n], points[-1], by_element = TRUE))
```

while their steepness can be extracted from the requested metadata.

```{r steepness}
steepness <- x$extras$steepness$values
steepness <- rep(steepness[,3], steepness[,2]-steepness[,1])
steepness <- factor(steepness, -5:5)

library(RColorBrewer)
palette = setNames(rev(brewer.pal(11, "RdYlBu")), levels(steepness))
```

For the final plot we use ggplot2 in combinations with ggforce which supports
handling of length units associated with the data.

```{r elevation_profile, fig.dim=c(10, 5), message=FALSE, out.height='100%'}
library("ggplot2")
library("ggforce")
library("units")

units(height) <- as_units("m")

df <- data.frame(x1 = c(set_units(0, "m"), segments[-(n-1)]),
                 x2 = segments,
                 y1 = height[-n],
                 y2 = height[-1],
                 steepness)

y_ran = range(height) * c(0.9, 1.1)

n = n-1

df2 = data.frame(x = c(df$x1, df$x2, df$x2, df$x1),
                 y = c(rep(y_ran[1], 2*n), df$y2, df$y1),
                 steepness,
                 id = 1:n)

ggplot() + theme_bw() +
  geom_segment(data = df, aes(x1, y1, xend = x2, yend = y2), size = 1) +
  geom_polygon(data = df2, aes(x, y, group = id), fill = "white") +
  geom_polygon(data = df2, aes(x, y , group = id, fill = steepness)) +
  scale_fill_manual(values = alpha(palette, 0.8), drop = FALSE) +
  scale_x_unit(unit = "km", expand = c(0,0)) +
  scale_y_unit(expand = c(0,0), limits = y_ran) +
  labs(x = "Distance", y = "Height")
```

Advanced `options` are passed in form of native R lists formatted as a JSON
object.

```{r bicycle-avoid}
polygon = list(
    type = "Polygon",
    coordinates = list(
      list(
        c(8.330469, 48.261570),
        c(8.339052, 48.261570),
        c(8.339052, 48.258227),
        c(8.330469, 48.258227),
        c(8.330469, 48.261570)
      )
    )
  )

options <- list(
  avoid_polygons = polygon
)

x <- ors_directions(coordinates, profile="cycling-mountain", options=options)

geojson <- list(
  type = "Feature",
  properties = "",
  geometry = polygon
)

leaflet() %>%
  addTiles() %>%
  addGeoJSON(geojson, color="#F00") %>%
  addGeoJSON(x, fill=FALSE) %>%
  fitBBox(x$bbox)
```


## Isochrones

Reachability has become a crucial component for many businesses from all
different kinds of domains. `ors_isochrones()` helps you to determine which
areas can be reached from certain location(s) in a given time or travel
distance. The reachability areas are returned as contours of polygons. Next to
the `range` provided in seconds or meters you may as well specify the
corresponding `interval`s. If the input entails a list of points the service
will return an intersections of the computed isochrones if any exist.
`ors_isochrones()` accepts similar arguments as `ors_directions()`.

```{r isochrones}
coordinates <- list(c(8.34234, 48.23424), c(8.34234, 47.23424))
range <- 60*60 # 60 minutes
interval <- 20*60 # 20 minutes

x <- ors_isochrones(coordinates, range = range, interval = interval)

# set isochrones color
ranges <- seq(from=interval, to=range, by=interval)
pal <- setNames(heat.colors(length(ranges)), ranges)

x$features <- lapply(1:length(x$features), function(i) {
  feature <- x$features[[i]]
  range <- feature$properties$value
  
  ## set style
  col <- unname(pal[as.character(range)])
  feature$properties$style <- list(color = col, fillColor = col, fillOpacity=0.5)
  
  ## restrict polygon to current level only
  if (range > ranges[1])
    feature$geometry$coordinates <-
      c(feature$geometry$coordinates, x$features[[i-1]]$geometry$coordinates)
  
  feature
})

leaflet() %>%
  addTiles() %>%
  addGeoJSON(x) %>%
  fitBBox(x$bbox)
```


## Matrix

One to many, many to many or many to one: `ors_matrix()` allows you to obtain
aggregated time and distance information between a set of locations (origins and
destinations). Unlike `ors_directions()` it does not return detailed route
information. But you may still specify the transportation mode and compute
routes which adhere to certain restrictions, such as avoiding specific road
types or object characteristics.

```{r matrix}
coordinates <- list(
  c(9.970093, 48.477473),
  c(9.207916, 49.153868),
  c(37.573242, 55.801281),
  c(115.663757,38.106467)
)

# query for duration and distance in km
res <- ors_matrix(coordinates, metrics = c("duration", "distance"), units = "km")

# duration in hours
(res$durations / 3600) %>% round(1)

# distance in km
res$distances %>% round
```

## Geocoding

`ors_geocode()` transforms a description of a location provided in `query`, such
as the place's name, street address or postal code, into a normalized
description of the location with a point geometry. Additionally, it offers
reverse geocoding which does exactly the opposite: It returns the next enclosing
object which surrounds the coordinates of the given `location`. To obtain more
relevant results you may also set a radius of tolerance around the requested
coordinates.

```{r geocode}
## locations of Heidelberg around the globe
x <- ors_geocode("Heidelberg")

leaflet() %>%
  addTiles() %>%
  addGeoJSON(x) %>%
  fitBBox(x$bbox)

## set the number of results returned
x <- ors_geocode("Heidelberg", size = 1)

## search within a particular country
x <- ors_geocode("Heidelberg", boundary.country = "DE")

## structured geocoding
x <- ors_geocode(list(locality="Heidelberg", county="Heidelberg"))

## reverse geocoding
location <- x$features[[1L]]$geometry$coordinates

y <- ors_geocode(location = location, layers = "locality", size = 1)
```


## POIs

This service allows you to find places of interest around or within given
geographic coordinates. You may search for given features around a point, path
or even within a given polygon specified in `geometry`. To list all the
available POI categories use `ors_pois('list')`.

```{r pois}
geometry <- list(
  geojson = list(
    type = "Point",
    coordinates = c(8.8034, 53.0756)
  ),
  buffer = 500
)

ors_pois(request = 'pois',
         geometry = geometry,
         limit = 2000,
         sortby = "distance",
         filters = list(
           category_ids = I(488),
           wheelchair = I("yes")
         ))
```

You can gather statistics on the amount of certain POIs in an area by using
`request='stats'`.

```{r stats}
ors_pois(request = 'stats',
         geometry = geometry,
         limit = 2000,
         sortby = "distance",
         filters = list(
           category_ids = I(488)
         ))
```


## Elevation

Given a point or line geometry you can use `ors_elevation` to query for its
elevation.

```{r elevation}
x <- ors_geocode("KÃ¶nigstuhl")

coordinates <- x$features[[1L]]$geometry$coordinates

ors_elevation("point", coordinates)
```
